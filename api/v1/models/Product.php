<?php

namespace panix\mod\shop\api\v1\models;


use panix\mod\shop\models\Attribute;
use \panix\mod\shop\api\v1\models\Category;
use panix\mod\shop\models\Product as BaseProduct;
use yii\helpers\Url;

/**
 * Class Product
 * @package api\modules\v1\models
 *
 *
 * GET v1/product?token={token} Список товаров
 * GET,PUT,DELETE v1/product/{id}?token={token} Товар
 *
 * $_GET params "&expand=characteristics,<etc>"
 * $_GET params "&field=id,<etc>"
 */
class Product extends BaseProduct
{

    public $images;

    public function scenarios()
    {
        $scenarios = parent::scenarios();
        $scenarios['api_create'] = ['name_ru', 'main_category_id', 'price', 'type_id'];
        $scenarios['api_update'] = ['name_ru', 'main_category_id', 'price'];
        return $scenarios;
    }
    public function getMainCategory()
    {
        return $this->hasOne(Category::class, ['id' => 'category'])
            ->via('categorization', function ($query) {
                /** @var Query $query */
                $query->where(['is_main' => 1]);
            });
    }
    public function getCategories()
    {
        return $this->hasMany(Category::class, ['id' => 'category'])->via('categorization');
    }
    public function fields()
    {
        $data = [];
        return [
            'id',
            'type' => function ($model) {
                return ['id' => $model->type_id, 'name' => $model->type->name];
            },
            'name_ru',
            'price',
            'sku',
            'switch',
            'availability',
            'created_at',
            'updated_at',
            'categories' => function ($model) {
                return [
                    'main_category' => $model->mainCategory,
                    'categories' => $model->categories
                ];
            },
            'brand' => function ($model) {
                if ($model->brand_id) {
                    return ['id' => $model->brand_id, 'name' => $model->brand->name];
                } else {
                    return null;
                }
            },
            /*'images' => function ($model) {
                $image = [];
                foreach ($model->getImages() as $img) {
                    $image[] = [
                        'id' => $img->id,
                        'is_main' => $img->is_main,
                        'url' => Url::to($img->getUrlToOrigin(), true),
                    ];

                }
                return $image;
            },*/
            'currency_id' => function ($model) {
                return ($model->currency_id) ? $model->currency_id : 'UAH';
            },
            'attributes' => function ($model) {
                $attributes = $model->getEavAttributes();
                $data = [];
                $query = Attribute::find()
                    ->where(['IN', 'name', array_keys($attributes)])
                    ->sort()
                    ->all();


                foreach ($query as $attr) {
                    /** @var Attribute $attr */
                    $value = $attr->renderValue($attributes[$attr->name]);
                    $data[] = [
                        'id' => $attr->id,
                        'title' => $attr->title,
                        'value' => $value
                    ];
                }
                return $data;
            },

        ];
    }

    public function extraFields()
    {
        return ['prices', 'characteristics'];
    }

    public function getCharacteristics()
    {
        $attributes = $this->getEavAttributes();

        $_list = [];

        $query = Attribute::find()
            ->where(['IN', 'name_ru', array_keys($attributes)])
            ->sort()
            ->all();

        foreach ($query as $m) {
            $_list[] = [
                'data' => $m,
                'value' => $m->renderValue($attributes[$m->name])
            ];

        }

        return $_list;
    }

    public function afterSave($insert, $changedAttributes)
    {

        parent::afterSave($insert, $changedAttributes); // TODO: Change the autogenerated stub
    }
}
